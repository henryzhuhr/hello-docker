import{_ as s,c as a,o as i,a5 as e}from"./chunks/framework.B6CAAedu.js";const u=JSON.parse('{"title":"Dockerfile","description":"","frontmatter":{"outline":"deep"},"headers":[],"relativePath":"docker-dockerfile.md","filePath":"docker-dockerfile.md","lastUpdated":1724512954000}'),l={name:"docker-dockerfile.md"},n=e(`<h1 id="dockerfile" tabindex="-1">Dockerfile <a class="header-anchor" href="#dockerfile" aria-label="Permalink to &quot;Dockerfile&quot;">​</a></h1><h2 id="dockerfile-简介" tabindex="-1">Dockerfile 简介 <a class="header-anchor" href="#dockerfile-简介" aria-label="Permalink to &quot;Dockerfile 简介&quot;">​</a></h2><p>Dockerfile 是一个用来构建 Docker 镜像的文本文件，其中包含了一条条构建镜像所需的指令。Dockerfile 中的每一条指令都会在镜像中创建一个新的层，每一层都是基于上一层构建的。</p><h2 id="使用-dockerfile-定制镜像" tabindex="-1">使用 Dockerfile 定制镜像 <a class="header-anchor" href="#使用-dockerfile-定制镜像" aria-label="Permalink to &quot;使用 Dockerfile 定制镜像&quot;">​</a></h2><div class="language-dockerfile vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">dockerfile</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">FROM</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> debian:stretch</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">RUN</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> apt-get update</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">RUN</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> apt-get install -y gcc libc6-dev make wget</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">RUN</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> wget -O redis.tar.gz </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">RUN</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> mkdir -p /usr/src/redis</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">RUN</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">RUN</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> make -C /usr/src/redis</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">RUN</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> make -C /usr/src/redis install</span></span></code></pre></div><p>Dockerfile 中每一个指令都会建立一层，<code>RUN</code> 也不例外。每一个 RUN 的行为，就和刚才我们手工建立镜像的过程一样：新建立一层，在其上执行这些命令，执行结束后，commit 这一层的修改，构成新的镜像。</p><p>而上面的这种写法，创建了 7 层镜像。这是完全没有意义的，而且很多运行时不需要的东西，都被装进了镜像里，比如编译环境、更新的软件包等等。结果就是产生非常臃肿、非常多层的镜像，不仅仅增加了构建部署的时间，也很容易出错。 这是很多初学 Docker 的人常犯的一个错误。</p><p>Union FS 是有最大层数限制的，比如 AUFS，曾经是最大不得超过 42 层，现在是不得超过 127 层。</p><p>上面的 Dockerfile 正确的写法应该是这样：</p><div class="language-dockerfile vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">dockerfile</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">FROM</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> debian:stretch</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">RUN</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> set -x; buildDeps=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;gcc libc6-dev make wget&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> \\</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &amp;&amp; apt-get update \\</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &amp;&amp; apt-get install -y $buildDeps \\</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &amp;&amp; wget -O redis.tar.gz </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> \\</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &amp;&amp; mkdir -p /usr/src/redis \\</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \\</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &amp;&amp; make -C /usr/src/redis \\</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &amp;&amp; make -C /usr/src/redis install \\</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &amp;&amp; rm -rf /var/lib/apt/lists/* \\</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &amp;&amp; rm redis.tar.gz \\</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &amp;&amp; rm -r /usr/src/redis \\</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &amp;&amp; apt-get purge -y --auto-remove $buildDeps</span></span></code></pre></div><p>首先，之前所有的命令只有一个目的，就是编译、安装 redis 可执行文件。因此没有必要建立很多层，这只是一层的事情。因此，这里没有使用很多个 RUN 一一对应不同的命令，而是仅仅使用一个 RUN 指令，并使用 &amp;&amp; 将各个所需命令串联起来。将之前的 7 层，简化为了 1 层。在撰写 Dockerfile 的时候，要经常提醒自己，这并不是在写 Shell 脚本，而是在定义每一层该如何构建。</p><p>首先，之前所有的命令只有一个目的，就是编译、安装 redis 可执行文件。因此没有必要建立很多层，这只是一层的事情。因此，这里没有使用很多个 RUN 一一对应不同的命令，而是仅仅使用一个 RUN 指令，并使用 &amp;&amp; 将各个所需命令串联起来。将之前的 7 层，简化为了 1 层。在撰写 Dockerfile 的时候，要经常提醒自己，这并不是在写 Shell 脚本，而是在定义每一层该如何构建。</p><p>并且，这里为了格式化还进行了换行。Dockerfile 支持 Shell 类的行尾添加 \\ 的命令换行方式，以及行首 # 进行注释的格式。良好的格式，比如换行、缩进、注释等，会让维护、排障更为容易，这是一个比较好的习惯。</p><p>此外，还可以看到这一组命令的最后添加了清理工作的命令，删除了为了编译构建所需要的软件，清理了所有下载、展开的文件，并且还清理了 apt 缓存文件。这是很重要的一步，我们之前说过，镜像是多层存储，每一层的东西并不会在下一层被删除，会一直跟随着镜像。因此镜像构建时，一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。</p><h2 id="dockerfile-指令" tabindex="-1">Dockerfile 指令 <a class="header-anchor" href="#dockerfile-指令" aria-label="Permalink to &quot;Dockerfile 指令&quot;">​</a></h2><h3 id="from" tabindex="-1">FROM <a class="header-anchor" href="#from" aria-label="Permalink to &quot;FROM&quot;">​</a></h3><h3 id="run" tabindex="-1">RUN <a class="header-anchor" href="#run" aria-label="Permalink to &quot;RUN&quot;">​</a></h3><h2 id="如何获取基础镜像" tabindex="-1">如何获取基础镜像 <a class="header-anchor" href="#如何获取基础镜像" aria-label="Permalink to &quot;如何获取基础镜像&quot;">​</a></h2><p>可以在 <a href="https://hub.docker.com/explore" target="_blank" rel="noreferrer">Docker Hub</a> 找到很多官方和非官方的镜像，也可以通过 <code>docker pull</code> 命令拉取镜像。</p><p>操作系统镜像：</p><ul><li><a href="https://hub.docker.com/_/ubuntu" target="_blank" rel="noreferrer">ubuntu</a><ul><li>24.04: <code>ubuntu:noble</code>, <code>ubuntu:rolling</code></li><li>20.04: <code>ubuntu:focal</code></li></ul></li></ul><h2 id="构建镜像" tabindex="-1">构建镜像 <a class="header-anchor" href="#构建镜像" aria-label="Permalink to &quot;构建镜像&quot;">​</a></h2><p>在根目录下创建一个 <code>Dockerfile</code> 文件，内容如下：</p><p>然后执行以下命令构建镜像：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">docker</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> build</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --pull</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --rm</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -t</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> hellodocker:v1.0</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;docker&quot;</span></span></code></pre></div>`,25),t=[n];function p(r,h,k,d,o,c){return i(),a("div",null,t)}const g=s(l,[["render",p]]);export{u as __pageData,g as default};
